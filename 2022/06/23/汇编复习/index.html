

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#111111">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="title:汇编语言基础内容excerpt:基于王爽老师《汇编语言程序设计》tags:[汇编]categories:[学习笔记]index_img:&#x2F;img&#x2F;6.jpg  物理地址CPU访问内存单元是要给出内存单元的地址。 8086的寻址能力和cpu的寻址能力不匹配，前者20位后者只有16位。 8086CPU的解决办法： 物理地址&#x3D;段地址*16+偏移地址（乘16相当">
<meta property="og:type" content="article">
<meta property="og:title" content="Living0908">
<meta property="og:url" content="http://example.com/2022/06/23/%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Living0908">
<meta property="og:description" content="title:汇编语言基础内容excerpt:基于王爽老师《汇编语言程序设计》tags:[汇编]categories:[学习笔记]index_img:&#x2F;img&#x2F;6.jpg  物理地址CPU访问内存单元是要给出内存单元的地址。 8086的寻址能力和cpu的寻址能力不匹配，前者20位后者只有16位。 8086CPU的解决办法： 物理地址&#x3D;段地址*16+偏移地址（乘16相当">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-23T07:06:19.591Z">
<meta property="article:modified_time" content="2022-07-11T01:47:01.562Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>Living0908</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#6633FF","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":"ture","baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"ywenJSpxiTrznHEJWpP4khXq-gzGzoHsz","app_key":"Hfz4gFtGkwzpXjQr72Edzjym","server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Living0908</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-06-23 15:06" pubdate>
        2022年6月23日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      107 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            <div class="markdown-body">
              <hr>
<p>title:汇编语言基础内容<br>excerpt:基于王爽老师《汇编语言程序设计》<br>tags:[汇编]<br>categories:[学习笔记]<br>index_img:&#x2F;img&#x2F;6.jpg</p>
<hr>
<h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>CPU访问内存单元是要给出内存单元的地址。</p>
<p>8086的寻址能力和cpu的寻址能力不匹配，前者20位后者只有16位。</p>
<p>8086CPU的解决办法：</p>
<p>物理地址&#x3D;段地址*16+偏移地址（乘16相当于把段地址左移一位）</p>
<p>一个物理地址不能决定段地址和偏移地址</p>
<h5 id="用两个16位的地址相加得到一个20位的物理地址"><a href="#用两个16位的地址相加得到一个20位的物理地址" class="headerlink" title="用两个16位的地址相加得到一个20位的物理地址"></a>用两个16位的地址相加得到一个20位的物理地址</h5><h3 id="用分段的方式管理内存"><a href="#用分段的方式管理内存" class="headerlink" title="用分段的方式管理内存"></a>用分段的方式管理内存</h3><p>内存并没有分段，段的划分来自于CPU</p>
<p>一个内存段的起始地址（基础地址）为段地址的十六倍</p>
<ul>
<li>一个段的起始地址一定是十六的倍数</li>
<li>编译地址为十六位，十六位地址的寻址能力为64k，所以一个段的最长大小为64k</li>
</ul>
<p>eg:数据在21F60H内存单元中，段地址是2000H，说法：</p>
<ul>
<li>数据存在内存2000：1FH单元中</li>
<li>数据存在2000H段中的1F60H单元中</li>
</ul>
<p>四个段寄存器：</p>
<p>CS代码寄存器</p>
<p>DS数据寄存器</p>
<p>SS栈段寄存器</p>
<p>ES附加寄存器</p>
<h3 id="debug的使用"><a href="#debug的使用" class="headerlink" title="debug的使用"></a>debug的使用</h3><p>借debug观察计算机内部的情况</p>
<p>1.启动debug：</p>
<p>2.R-查看寄存器内容：R 寄存器名， 再进行改变</p>
<p>3.D-查看内存中的内容</p>
<p>​	D 列出预设地址内存处的128个字节的内容</p>
<p>​	D 段地址：偏移地址</p>
<p>4.E-改变内存中的内容：</p>
<p>​	E 段地址：偏移地址 数据1 数据2 数据3……</p>
<p>​	E  段地址：偏移地址 原数据.新数据 原数据.新数据……</p>
<p>5.U命令间隔你存中的机器指令翻译成汇编指令</p>
<ul>
<li>E 段地址：偏移地址 -写入地址（写入的全是对应的机器码）</li>
<li>D 地址-查看</li>
<li>U 地址-查看代码</li>
</ul>
<p>6 . A-以汇编指令的格式写入命令：A 地址</p>
<p>7 .T-执行机器指令：CS:IP 处的指令（单步执行）</p>
<p>8 . q退出</p>
<h3 id="CS-IP与代码段"><a href="#CS-IP与代码段" class="headerlink" title="CS:IP与代码段"></a>CS:IP与代码段</h3><p>CS:代码寄存器</p>
<p>IP：指令指针寄存器（只有CPU自己能够进行修改，不能用mov）</p>
<p>1.从所指向的内存单元读取指令，读取的指令进入指令缓冲器</p>
<p>2.IP&#x3D;IP+所读取指令的长度，从而指向下一条指令</p>
<p>3.执行指令，转到步骤1，重复过程</p>
<h6 id="先-r看一哈cs和ip的指向哪里，再修改值，向相应的单元写入数据，再A，再U查看，也可以用D"><a href="#先-r看一哈cs和ip的指向哪里，再修改值，向相应的单元写入数据，再A，再U查看，也可以用D" class="headerlink" title="先-r看一哈cs和ip的指向哪里，再修改值，向相应的单元写入数据，再A，再U查看，也可以用D"></a>先-r看一哈cs和ip的指向哪里，再修改值，向相应的单元写入数据，再A，再U查看，也可以用D</h6><h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h3><h5 id="修改CS，IP-的方法："><a href="#修改CS，IP-的方法：" class="headerlink" title="修改CS，IP 的方法："></a>修改CS，IP 的方法：</h5><p>1.rcs,rip进行修改，但是不现实，debug是调试手段</p>
<p>2.转移指令jmp：</p>
<p>​	同时修改cs,ip：jmp 段地址：偏移地址</p>
<p>​	仅修改ip的内容：jmp 某一合法寄存器（jmp ax&#x3D;mov ip ax但是后者不能用)</p>
<h5 id="jmp可以用于循环"><a href="#jmp可以用于循环" class="headerlink" title="jmp可以用于循环"></a>jmp可以用于循环</h5><h3 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h3><p>对于8086CPU,16位作为一个字，16位的字在内存中需要两个连续字节存储：</p>
<h5 id="低位字节存放在低地址单元，高位字节存放在高地址单元"><a href="#低位字节存放在低地址单元，高位字节存放在高地址单元" class="headerlink" title="低位字节存放在低地址单元，高位字节存放在高地址单元"></a>低位字节存放在低地址单元，高位字节存放在高地址单元</h5><p>eg：4B20H存放在0，1两个单元。20存放在0单元，4B放在1单元</p>
<p>​			0地址单元中存放的<strong>字节数据</strong>是20H</p>
<p>​			0地址字单元存放的<strong>字型数据</strong>是4E20H</p>
<h6 id="读的时候先读高地址单元再读低地址单元"><a href="#读的时候先读高地址单元再读低地址单元" class="headerlink" title="读的时候先读高地址单元再读低地址单元"></a>读的时候先读高地址单元再读低地址单元</h6><h3 id="用DS和-address-实现字的传送"><a href="#用DS和-address-实现字的传送" class="headerlink" title="用DS和[address]实现字的传送"></a>用DS和[address]实现字的传送</h3><p>CPU从内存单元中读取数据：</p>
<p>​	用DS寄存器存放要访问数据的段地址</p>
<p>​	偏移地址用[……]的形式直接给出</p>
<p>eg:mov bx,1000h</p>
<p>​	mov ds,bx</p>
<p>​	mov al,[0]</p>
<p>以上代码段的意思是将1000：0处的数据读到al中</p>
<p>eg:mov bx,1000h</p>
<p>​	mov ds,bx</p>
<p>​	mov [0]，al</p>
<p>以上代码段的意思是将al中的数据写到1000：0中</p>
<h6 id="不支持将数据直接送入段寄存器，要先送入基础寄存器"><a href="#不支持将数据直接送入段寄存器，要先送入基础寄存器" class="headerlink" title="不支持将数据直接送入段寄存器，要先送入基础寄存器"></a>不支持将数据直接送入段寄存器，要先送入基础寄存器</h6><h6 id="每次读两个单元，如果为-0-则读的实际数据是-1-0"><a href="#每次读两个单元，如果为-0-则读的实际数据是-1-0" class="headerlink" title="每次读两个单元，如果为[0],则读的实际数据是[1] [0]"></a>每次读两个单元，如果为[0],则读的实际数据是[1] [0]</h6><h3 id="DS与数据段"><a href="#DS与数据段" class="headerlink" title="DS与数据段"></a>DS与数据段</h3><p>将哪段内存当作数据段，段地址如何定，在编程时安排</p>
<p>​	用DS存放数据段的段地址</p>
<p>​	用相关指令访问数据的具体单元，单元地址有[address]给出</p>
<p>eg:累加数据段中前3个单元的数据：add al,[0]    add al,[1]	add al,[2]</p>
<p>​	累加数据段中前3个字型数据：add ax,[0]	add ax,[2]	add ax,[4]</p>
<h3 id="栈及栈操作的实现"><a href="#栈及栈操作的实现" class="headerlink" title="栈及栈操作的实现"></a>栈及栈操作的实现</h3><p> 栈是一种只能在一端进行插入或者删除的数据结构</p>
<p>入栈push：</p>
<p>​	push ax 将ax中的数据送入栈中</p>
<p>出栈pop:</p>
<p>​	pop ax 将栈顶的数据送入ax</p>
<h6 id="都是以字为单位进行的操作-栈越往上内存地址越小"><a href="#都是以字为单位进行的操作-栈越往上内存地址越小" class="headerlink" title="都是以字为单位进行的操作,栈越往上内存地址越小"></a>都是以字为单位进行的操作,栈越往上内存地址越小</h6><h5 id="CPU如何知道一段内存被当作栈使用？"><a href="#CPU如何知道一段内存被当作栈使用？" class="headerlink" title="CPU如何知道一段内存被当作栈使用？"></a>CPU如何知道一段内存被当作栈使用？</h5><p>SS是栈段寄存器：存放栈顶的段地址</p>
<p>SP是栈顶指针寄存器：存放栈顶的偏移地址</p>
<h6 id="任何时刻，SS：SP指向栈顶元素"><a href="#任何时刻，SS：SP指向栈顶元素" class="headerlink" title="任何时刻，SS：SP指向栈顶元素"></a>任何时刻，SS：SP指向栈顶元素</h6><h5 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h5><p>push ax:</p>
<p>​	SP&#x3D;SP-2</p>
<p>​	将ax中的内容送入SS：SP指向的内存单元，指向新栈顶SS: SP</p>
<p>pop ax:</p>
<p>​	将SS :SP指向的内存单元处的数据送入ax中</p>
<p>​	SP&#x3D;SP+2</p>
<h5 id="栈顶超界问题"><a href="#栈顶超界问题" class="headerlink" title="栈顶超界问题"></a>栈顶超界问题</h5><p>栈顶超界是危险的，在执行push和pop指令都可能出现</p>
<p>CPU不保证栈顶不会超界</p>
<h3 id="段的总结"><a href="#段的总结" class="headerlink" title="段的总结"></a>段的总结</h3><p>物理地址&#x3D;段地址*16+偏移地址</p>
<h5 id="数据段："><a href="#数据段：" class="headerlink" title="数据段："></a>数据段：</h5><p>段地址放在DS中，与[address]搭配使用，用mov,add,sub等访问时将内存单元中的内容当作数据来访问</p>
<h5 id="代码段："><a href="#代码段：" class="headerlink" title="代码段："></a>代码段：</h5><p>CS和IP用于指向要寻找的代码段</p>
<h5 id="栈段："><a href="#栈段：" class="headerlink" title="栈段："></a>栈段：</h5><p>SS和SP,采用push和pop指令，其中SP的加减取决于指令，需要进行栈段的操作是就用这个</p>
<h5 id="三个段地址可以一样"><a href="#三个段地址可以一样" class="headerlink" title="三个段地址可以一样"></a>三个段地址可以一样</h5><h3 id="用汇编语言写的源程序"><a href="#用汇编语言写的源程序" class="headerlink" title="用汇编语言写的源程序"></a>用汇编语言写的源程序</h3><p>汇编程序——编译器——机器码——计算机执行</p>
<p>汇编代码中的汇编指令称为伪指令</p>
<h5 id="段定义："><a href="#段定义：" class="headerlink" title="段定义："></a>段定义：</h5><p>一个汇编程序是由多个段组成的，这些段被用来存放代码，数据，或者当作栈空间来使用</p>
<p>一个有意义的汇编程序至少要有一个段，这个段用来存放代码</p>
<h6 id="定义程序的段：每个段都需要段名"><a href="#定义程序的段：每个段都需要段名" class="headerlink" title="定义程序的段：每个段都需要段名"></a>定义程序的段：每个段都需要段名</h6><p>eg:段名 segment——段的开始</p>
<p>​	 段名 ends——段的结束</p>
<h5 id="end"><a href="#end" class="headerlink" title="end:"></a>end:</h5><p>不是<strong>ends</strong> ，若程序结尾处不加end，编译器在编译程序时不知道程序在何处结束</p>
<h5 id="assume："><a href="#assume：" class="headerlink" title="assume："></a>assume：</h5><p>假设某一段寄存器和程序中某一个用segment……ends定义的相关段相关联——assume cs:codesg指的是CS寄存器和codesg关联，将定义的codesg当作程序的代码段使用</p>
<h5 id="汇编程序-asm——可执行程序-exe："><a href="#汇编程序-asm——可执行程序-exe：" class="headerlink" title="汇编程序.asm——可执行程序.exe："></a>汇编程序.asm——可执行程序.exe：</h5><p>1.在debug中直接写入指令：适用于功能简单，短小精悍</p>
<p>2.单独写源程序文件后再进行编译：适用于编写大程序，需要包括汇编指令还需要伪指令，由段构成</p>
<h5 id="如何写一个程序："><a href="#如何写一个程序：" class="headerlink" title="如何写一个程序："></a>如何写一个程序：</h5><p>编程求2^3:</p>
<p>定义一个段</p>
<p>实现处理任务</p>
<p>指出程序在何处结束</p>
<p>短语寄存器的关联</p>
<p>加上程序返回时的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs assembly">assume cs:abc<br>abc segment<br>    mov ax,2<br>    add ax,ax<br>    add ax,ax<br>    <br>    mov ax,4c00h<br>    int 21h;表示返回正常<br>abc ends<br>end<br><br></code></pre></td></tr></table></figure>

<h5 id="程序可能发现的错误："><a href="#程序可能发现的错误：" class="headerlink" title="程序可能发现的错误："></a>程序可能发现的错误：</h5><p>语法错误：编译时被编译器发现</p>
<p>逻辑错误</p>
<h3 id="由源程序到程序运行"><a href="#由源程序到程序运行" class="headerlink" title="由源程序到程序运行"></a>由源程序到程序运行</h3><h5 id="编辑源程序："><a href="#编辑源程序：" class="headerlink" title="编辑源程序："></a>编辑源程序：</h5><p>写好asm文件</p>
<h5 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h5><p>masm xx.asm,得到目标文件xx.obj，或者直接masm,再进行写文件名</p>
<h5 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h5><p>link (obj的名字)</p>
<p>no stack segment可以不管</p>
<h3 id="用debug跟踪程序运行"><a href="#用debug跟踪程序运行" class="headerlink" title="用debug跟踪程序运行"></a>用debug跟踪程序运行</h3><p>用法：debug xx.exe</p>
<p>程序加载后，DS中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为DS：0</p>
<p>这个内存区的前256个字节村PSP（段前缀），DOS用来和程序进行通信，256字节后的空间存放处是程序，CS的值为DS+10H</p>
<p>程序加载后CX中存放代码的长度</p>
<p>-t单步执行</p>
<p>-p类似t命令，但遇到子程序或者中断时，直接执行然后显示结果</p>
<h3 id="…-…"><a href="#…-…" class="headerlink" title="[…] (…)"></a>[…] (…)</h3><p>[]——在汇编语法中表示一个内存单元，根据ax和al判断操作单位是字还是字节：[bx]&#x3D;((ds)*16+(bx))</p>
<p>()——在学习中为了方便做出的约定，表示一个内存单元或寄存器的内容：(ax)&#x3D;0010H</p>
<p>idata——表示常量</p>
<p>inc :加一指令</p>
<h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>功能：循环（计数型循环）</p>
<p>CPU执行loop指令是要进行的操作</p>
<p>​	（cx）&#x3D;(cx)-1</p>
<p>​	  判断CX中的值：不为0则转至表好处执行程序，如果为0则向下执行</p>
<p>要求：	cx中要提前存放循环次数，因为（cx)影响这loop指令执行的结果，定义一个标号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br>code segment<br>	mov ax,2<br>	mov cx,11<br>   s:add ax,ax;计算2^12<br>    loop s<br>    <br>    mov ax,4c00h<br>    int 21h<br>code ends<br>end<br></code></pre></td></tr></table></figure>

<p>用loop实现循环的三个要点：</p>
<p>1.在cx中存放循环次数</p>
<p>2.用标号指定循环开始的位置</p>
<p>3.在标号和loop指令的中间要写上循环执行的程序段（循环体）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算 123*236，用加法解决乘法<br>assume cs:code <br>code segment<br>	mov ax,0<br>	mov cx,123<br>	s:add ax 256<br>	loop s<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算ffff:0006字节单元中的数乘以3，结果储存在DX中<br>assume cs:code<br>code segment<br>	mov ax,0ffffh;汇编源程序中，数据不能以字母开头，要在ffff前加0<br>	mov ds,ax<br>	mov bx,6<br>	mov al,[bx];将题目中内存单元的数据放入ax中，要求以字节单元<br>	mov ah,0;将高八位置零<br>	<br>	mov dx,0<br>	mov cx,3<br>	s:add dx,ax<br>	loop s<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end<br>;要考虑会不会溢出<br></code></pre></td></tr></table></figure>

<h3 id="段前缀的使用"><a href="#段前缀的使用" class="headerlink" title="段前缀的使用"></a>段前缀的使用</h3><p>为了防止在程序段中的mov ax,[0]这种类似的形式在编译时被编译成<strong>mov</strong> <strong>ax</strong> ,<strong>00</strong>被当成了数据而不是偏移地址</p>
<p>对策：在[idata]前显式的加上寄存器：mov ax,ds:[bx]</p>
<h5 id="访问连续的内存单元：loop和-bx-联手"><a href="#访问连续的内存单元：loop和-bx-联手" class="headerlink" title="访问连续的内存单元：loop和[bx]联手"></a>访问连续的内存单元：loop和[bx]联手</h5><p>问题：计算ffff:0~ffff:b字节单元中的数据的和，结果储存在dx中？</p>
<p>对策：取出8位数据，加到16位寄存器</p>
<p>​	mov al,ds:[addr]</p>
<p>​	mov ah,0</p>
<p>​	add dx,ax</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算ffff:0~ffff:b字节单元中的数据的和，结果储存在dx中？<br>;采用loop循环<br>assume cs:code<br>code segment<br>	mov ax,0ffffh<br>	mov ds,ax<br>	<br>	mov bx,0<br>	mov cx,11<br>	mov dx,0<br>	s:mov al,[bx]<br>	mov ah,0<br>	add dx,ax<br>	inc bx<br>	loop s<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end<br>;当程序段中有多个段的时候，如拷贝，此时段前缀很有用，es称为附加段寄存器，段前缀不一样，偏移量一样<br></code></pre></td></tr></table></figure>

<h3 id="在代码中使用数据"><a href="#在代码中使用数据" class="headerlink" title="在代码中使用数据"></a>在代码中使用数据</h3><p>问题：</p>
<p>​	在程序中直接写地址是危险的</p>
<p>对策：</p>
<p>​	在程序的段中存放数据，运行时由操作系统分配空间</p>
<p>​	段的类别：数据段，代码段，栈段</p>
<p>​	各种段中均可以有数据</p>
<p>​	可以在单个段中安置，也可以将数据，代码，栈放入不同的段中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;编程计算八个数据的和，结果存在ax寄存器中、<br>;dw定义一个字；db定义一个字节；dd定义一个双字<br>assume cs:code<br>code segment<br>	dw 0123h,0456h,0789h,0defh,0fedh,0cbah,0987h;将所有数据以字的行书存放在代码段中<br>	<br>	mov bx,0<br>	mov ax,0<br>	mov cx,8;用作循环<br>	<br>	s:add ax,cs:[bx]<br>	add bx,2<br>	loop s<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end<br>;该程序前属于数据段，而ip存放的从0开始，所以该代码段存在不足<br>;要求从代码段开始<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;改进<br>assume cs:code<br>code segment<br>	dw 0123h,0456h,0789h,0defh,0fedh,0cbah,0987h;将所有数据以字的行书存放在代码段中<br>	<br>	start:mov bx,0<br>	mov ax,0<br>	mov cx,8;用作循环<br>	<br>	s:add ax,cs:[bx]<br>	add bx,2<br>	loop s<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end start<br>;此时代码的开始从代码段开始<br></code></pre></td></tr></table></figure>

<h3 id="在代码中使用栈"><a href="#在代码中使用栈" class="headerlink" title="在代码中使用栈"></a>在代码中使用栈</h3><p>问题：利用栈，将程序中定义的数据逆序存放</p>
<p>对策：依次将八个子单元的数据入栈，在出栈，实现逆序。可以定义空来取得空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br>code segment<br>	dw 0123h,0456h,0789h,0defh,0fedh,0cbah,0987h;将所有数据以字的行书存放在代码段中<br>	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0;栈段，占用32个字节，此时代码段从30h开始，故此时的sp在30h<br>	<br> start:mov ax,cs<br>	mov ss,ax<br>	mov sp,30h<br>	<br>	;入栈<br>	mov bx,0<br>	mov cx,8<br> s0:push cs:[bx]<br>	add bx,2<br>	loop s0<br>	<br>	;出栈<br>	mov bx,0<br>	mov cx,8<br> s1:pop cs:[bx]<br>	add bx,2<br>	loop s0<br>	<br> 	mov ax,4c00h<br> 	int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<h3 id="将数据，代码，栈放入不同段"><a href="#将数据，代码，栈放入不同段" class="headerlink" title="将数据，代码，栈放入不同段"></a>将数据，代码，栈放入不同段</h3><p>特点：三种都在一个段</p>
<p>功能：应用于要处理的数据很少，用到的占空间也小，加上没有多长的代码</p>
<p>对策：遇到很大的放入不同段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code,ds:data,ss:stack<br>data segmemt<br>	dw 0123h,0456h,0789h,0defh,0fedh,0cbah,0987h;将所有数据以字的行书存放在代码段中<br>data ends<br>stack segment<br>	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br>stack ends<br>code segment<br>	start:<br>	;初始化各段寄存器，CS是默认的，不需要初始化<br>	mov ax,data<br>	mov ds,ax<br>	mov ax,stack<br>	mov ss,ax<br>	mov so,20h;实际所占内存加一<br>	<br>	;入栈<br>	mov bx,0<br>	mov cx,8<br> s0:push [bx];此时不指明也知道就是ds中的<br> 	add bx,2<br> 	loop s<br> 	<br> 	;出栈<br> 	mov bx,0<br> 	mov cx,8<br> s1:pop [bx]<br> 	add bx,2<br> 	loop s1<br> 	<br> 	mov ax,4c00h<br> 	int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<h3 id="处理字符问题"><a href="#处理字符问题" class="headerlink" title="处理字符问题"></a>处理字符问题</h3><p>汇编程序中，用’……’的方式指明数据是字符串，转化为ASCII码</p>
<p>大写字母的ASCII比小写的小20H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;解决大小写转换的问题<br>;首字母大写全部转化为大写，首字母为小写全部转化为小写<br>assume cs:code,ds:datasg<br>datasg segment<br>	db &#x27;BasIc&#x27;<br>	db &#x27;iNfoRMaTiOn&#x27;<br>datasg ends<br>code segment<br>	start:mov ax,datasg<br>	mov ds,ax<br>	mov bx,0<br>	mov cx,5<br>	s:mov al,[bx]<br>	and al,11011111b;小写字母转化为大写<br>	mov [bx],al<br>	inc bx<br>	loop s<br>	<br>	mov bx,5<br>	mov cx,11<br>	s1:mov al,[bx]<br>	or al,00100000b;大写字母转化为小写<br>	mov [bx],al<br>	inc bx<br>	loop s1<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<h3 id="bx-idata-寻址方式"><a href="#bx-idata-寻址方式" class="headerlink" title="[bx+idata]寻址方式"></a>[bx+idata]寻址方式</h3><p>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata</p>
<p>mov ax,[bx+200]的含义：</p>
<p>​	将一个内存单元送入ax</p>
<p>​	这个内存单元长度为两个字节，存放一个字</p>
<p>​	内存单元的段地址在ds内，偏移地址为200加上bx中的数值</p>
<p>​	数学化的描述为：(ax)&#x3D;((ds)*16+200+(bx))</p>
<h5 id="bx-200-还能表示为-200-bx-bx-200-200-bx"><a href="#bx-200-还能表示为-200-bx-bx-200-200-bx" class="headerlink" title="[bx+200]还能表示为[200+bx],[bx].200,200[bx]"></a>[bx+200]还能表示为[200+bx],[bx].200,200[bx]</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;用[bx+idata]处理上面的问题<br>;解决大小写转换的问题<br>;首字母大写全部转化为大写，首字母为小写全部转化为小写<br>assume cs:code,ds:datasg<br>datasg segment<br>	db &#x27;BasIc&#x27;<br>	db &#x27;iNfoRMaTiOn&#x27;<br>datasg ends<br>code segment<br>	start:mov ax,datasg<br>	mov ds,ax<br>	mov bx,0<br>	mov cx,5<br>	s:mov al,[bx]<br>	and al,11011111b;小写字母转化为大写<br>	mov [bx],al<br><br>	mov al,[bx+5];采用本节内容<br>	or al,00100000b<br>	mov [bx+5],al<br>	inc bx;只在末尾加一次1就可以了<br>	loop s<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<h3 id="变址寄存器SI和DI"><a href="#变址寄存器SI和DI" class="headerlink" title="变址寄存器SI和DI"></a>变址寄存器SI和DI</h3><h6 id="si和di是和bx功能相近的寄存器，也能-si-idata-di-idata"><a href="#si和di是和bx功能相近的寄存器，也能-si-idata-di-idata" class="headerlink" title="si和di是和bx功能相近的寄存器，也能[si+idata],[di+idata]"></a>si和di是和bx功能相近的寄存器，也能[si+idata],[di+idata]</h6><h6 id="bx-si-bx-di-也可以用来指定地址"><a href="#bx-si-bx-di-也可以用来指定地址" class="headerlink" title="[bx+si] [bx+di]也可以用来指定地址"></a>[bx+si] [bx+di]也可以用来指定地址</h6><p>[bx+si]表示一个内存单元：偏移地址为bx的数值加上si的数值</p>
<p>bx叫做基址，si叫做变址</p>
<h6 id="bx-si-idata-bx-di-idata-也可以用来指定地址"><a href="#bx-si-idata-bx-di-idata-也可以用来指定地址" class="headerlink" title="[bx+si+idata] [bx+di+idata]也可以用来指定地址"></a>[bx+si+idata] [bx+di+idata]也可以用来指定地址</h6><p>[bx+si+200]的其他写法：[bx+200+si] ,[bx].200[si] ,[bx] [sx].200,200[bx] [si]<strong>数值跟在寄存器后面要加点</strong></p>
<h3 id="寻址方式总结"><a href="#寻址方式总结" class="headerlink" title="寻址方式总结"></a>寻址方式总结</h3><p>[idata]直接寻址</p>
<p>[bx]寄存器寻址</p>
<p>[bx+idata]寄存器相对寻址</p>
<p>[bx+si]基址变址寻址</p>
<p>[bx+si+idata]相对基址变址寻址</p>
<h3 id="用于内存寻址的寄存器用法"><a href="#用于内存寻址的寄存器用法" class="headerlink" title="用于内存寻址的寄存器用法"></a>用于内存寻址的寄存器用法</h3><p>只有idata,bx,bp,si,di可以用于内存单元寻址，可以往方括号[]里面放</p>
<h5 id="bx-bp-si-di-不能这样用，是错误的"><a href="#bx-bp-si-di-不能这样用，是错误的" class="headerlink" title="[bx+bp] [si+di]不能这样用，是错误的"></a>[bx+bp] [si+di]不能这样用，是错误的</h5><h5 id="bp默认的是SS段，bx默认的是DS段，如果指定了段前缀就用指定的段"><a href="#bp默认的是SS段，bx默认的是DS段，如果指定了段前缀就用指定的段" class="headerlink" title="bp默认的是SS段，bx默认的是DS段，如果指定了段前缀就用指定的段"></a>bp默认的是SS段，bx默认的是DS段，如果指定了段前缀就用指定的段</h5><h3 id="数据的位置和长度"><a href="#数据的位置和长度" class="headerlink" title="数据的位置和长度"></a>数据的位置和长度</h3><p>1.数据的位置</p>
<p>​	idata:称为立即数，数据包含在指令中</p>
<p>​	寄存器：要处理的数据在寄存器中，给出相应的寄存器名字</p>
<p>​	内存：段地址SA和偏移地址EA</p>
<p>2.数据的长度</p>
<p>​	字：word操作，16位，ax</p>
<p>​	字节：byte操作，8位,al</p>
<p>​	未知ax或者al：用word ptr或者byte ptr指明（eg:mov word ptr ds:[0],1）</p>
<h3 id="div除法指令"><a href="#div除法指令" class="headerlink" title="div除法指令"></a>div除法指令</h3><p>使用div做除法的时候：被除数默认放在AX和DX和AX中，除数放在寄存器或者内存单元中</p>
<p>除数为8位内存或者寄存器则AL放商，AH放余数，除数位16位寄存器或者内存，则AX放商，DX放余数</p>
<p>eg:div bx 被除数：(DX*10000H+AX) 除数：(BX) 商：AX 余数：DX</p>
<h5 id="提前在默认的寄存器中设置好被除数，且默认寄存器不做别的用处，可以把其中的数据装在内存单元或者压栈"><a href="#提前在默认的寄存器中设置好被除数，且默认寄存器不做别的用处，可以把其中的数据装在内存单元或者压栈" class="headerlink" title="提前在默认的寄存器中设置好被除数，且默认寄存器不做别的用处，可以把其中的数据装在内存单元或者压栈"></a>提前在默认的寄存器中设置好被除数，且默认寄存器不做别的用处，可以把其中的数据装在内存单元或者压栈</h5><h3 id="dup的功能和用法"><a href="#dup的功能和用法" class="headerlink" title="dup的功能和用法"></a>dup的功能和用法</h3><p>功能：dup和db,dw,dd等数据定义伪指令配合使用，用来进行数据的重复</p>
<p>eg:</p>
<p>​	db 3 dup(0)	定义了三个字节，它们的值都是0	相当于db 0,0,0</p>
<p>​	db 3 dup(0,1,2)	定义了九个字节，由0，1，2重复构成</p>
<p>​	db 3 dup(‘abc’,’ABC’)	定义了18个字节，构成‘abcABCabcABCabcABC’,一个字符一个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;定义一个容量为200字节的栈段<br>stack  segment<br>	db 200 dup(0)<br>stack ends<br></code></pre></td></tr></table></figure>

<h3 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h3><p>用offset获得标号的偏移地址</p>
<p>eg:mov si,offset s</p>
<h3 id="jmp无条件转移"><a href="#jmp无条件转移" class="headerlink" title="jmp无条件转移"></a>jmp无条件转移</h3><p>无条件转移，可以只修改IP,也可以修改CS,IP</p>
<p>​	段间转移（远转移）：jmp 2000:0，源程序不能这样，只能在debug中使用</p>
<p>​	段内短转移：jmp short 标号，八位的位移量是指标号处的地址与jmp后一条指令地址的差，差要在-128~127之间</p>
<p>​	段内近转移：jmp near ptr 标号，十六位的转移量与上面差不多，但是差值的范围更大</p>
<p>​	远转移：far ptr指明了跳转到的目的地址，包含了标号的段地址和偏移地址</p>
<p>​	寄存器：jmp ax,IP&#x3D;(AX)十六位</p>
<p>​	内存：段内：jmp word ptr 地址两个字节</p>
<p>​				段间：jmp dword ptr 地址，段地址在高位，偏移地址在低位四个字节</p>
<h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>格式：jcxz 标号</p>
<p>功能：如果（cx)&#x3D;0,则转移到目的标号处执行</p>
<p>​			当(cx)！&#x3D;0时，则顺序执行</p>
<p>所有有条件的转移均为短转移</p>
<h3 id="call指令和ret指令"><a href="#call指令和ret指令" class="headerlink" title="call指令和ret指令"></a>call指令和ret指令</h3><p>调用子程序：call</p>
<p>返回：ret</p>
<h5 id="call："><a href="#call：" class="headerlink" title="call："></a>call：</h5><p>字面意思：调用子程序</p>
<p>实质：流程转移，与jmp相似</p>
<p>格式：call 标号</p>
<p>操作：</p>
<p>​	将当前IP或者CS和IP压入栈中</p>
<p>​	转移到标号处执行指令</p>
<p>​	16位位移量</p>
<p>​	call far ptr 可以实现段间转移</p>
<h6 id="相当于压栈和jmp的结合体"><a href="#相当于压栈和jmp的结合体" class="headerlink" title="相当于压栈和jmp的结合体"></a>相当于压栈和jmp的结合体</h6><h5 id="ret"><a href="#ret" class="headerlink" title="ret:"></a>ret:</h5><p>功能：用栈中的数据，修改IP的内容，实现金砖一，相当于pop IP</p>
<p>​			没有call也可以用ret，实际上转移到出栈的数据所代表的位置</p>
<p>retf:可以实现远转移</p>
<h3 id="乘法mul指令"><a href="#乘法mul指令" class="headerlink" title="乘法mul指令"></a>乘法mul指令</h3><p>八位乘法：被乘数放在AL中，结果放在AX中</p>
<p>十六位乘法：被乘数放在AX中，结果高十六位放在DX，第十六位放在AX</p>
<h3 id="模块化程序设计"><a href="#模块化程序设计" class="headerlink" title="模块化程序设计"></a>模块化程序设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;根据提供的N，计算三次方<br>;用寄存器来存储出参数和结果是最常用的方法<br>cube:mov ax,bx;ax和dx用来保存最终的结果<br>	mul bx<br>	mul bx<br>	ret<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算第一段数据的三次方，结果保存在后面一组<br>assume cs:code,ds:data<br>data segment<br>	dw 1,2,3,4<br>	dd 0,0,0,0<br>data ends<br>codesegment<br>start:mov ax,data<br>	mov ds,ax<br>	mov si,0<br>	mov di,8<br>	<br>	;进行循环处理<br>	mov cx,4<br>	S:mov,bx,[si]<br>	call cube<br>	mov [di],ax;结果的低位放在ax中<br>	mov [di.2,dx;高位放在dx中<br>	add si,2<br>	add,di,4<br>	loop s<br>	<br>	cube:mov ax,bx<br>	mul bx<br>	mul bx<br>	ret<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<h5 id="还可以用栈（栈顶sp放ip）和内存单元传递参数"><a href="#还可以用栈（栈顶sp放ip）和内存单元传递参数" class="headerlink" title="还可以用栈（栈顶sp放ip）和内存单元传递参数"></a>还可以用栈（栈顶sp放ip）和内存单元传递参数</h5><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>标志寄存器是按位起作用的，每一位都有专门的含义</p>
<p>8086的1，3，5，12，13，14，15位不具有任何意义</p>
<p>标志寄存器的作用：</p>
<p>​	用来储存相关指令的某些执行结果</p>
<p>​	用来为CPU执行相关指令提供行为依据</p>
<p>​	用来控制CPU的相关工作方式</p>
<p>直接访问标志寄存器的方法：</p>
<p>​	pushf 将标志寄存器的值压入栈</p>
<p>​	popf 从栈中弹出数据，送入标志寄存器</p>
<h5 id="ZF-零标志（zero-flag）"><a href="#ZF-零标志（zero-flag）" class="headerlink" title="ZF-零标志（zero flag）"></a>ZF-零标志（zero flag）</h5><p>ZF&#x3D;1，表示结果是0</p>
<p>ZF&#x3D;0,表示结果不是0</p>
<h5 id="PF-奇偶标志（parity-flag）"><a href="#PF-奇偶标志（parity-flag）" class="headerlink" title="PF-奇偶标志（parity flag）"></a>PF-奇偶标志（parity flag）</h5><p>PF&#x3D;1,1的个数是偶数</p>
<p>PF&#x3D;0,1的个数是奇数</p>
<h5 id="SF-符号标志（sign-flag）"><a href="#SF-符号标志（sign-flag）" class="headerlink" title="SF-符号标志（sign flag）"></a>SF-符号标志（sign flag）</h5><p>SF&#x3D;1，结果为负</p>
<p>SF&#x3D;0，结果为正</p>
<h5 id="CF-进位标志（carry-flag）"><a href="#CF-进位标志（carry-flag）" class="headerlink" title="CF-进位标志（carry flag）"></a>CF-进位标志（carry flag）</h5><p>CF&#x3D;1,有进位</p>
<p>CF&#x3D;0，无进位</p>
<h5 id="OF-溢出标志（overflow-flag）"><a href="#OF-溢出标志（overflow-flag）" class="headerlink" title="OF-溢出标志（overflow flag）"></a>OF-溢出标志（overflow flag）</h5><p>OF&#x3D;1,有溢出</p>
<p>OF&#x3D;0,无溢出</p>
<h3 id="adc是带进位加法指令"><a href="#adc是带进位加法指令" class="headerlink" title="adc是带进位加法指令"></a>adc是带进位加法指令</h3><p>利用了CF位上是否有进位</p>
<h3 id="cmp和条件转移指令"><a href="#cmp和条件转移指令" class="headerlink" title="cmp和条件转移指令"></a>cmp和条件转移指令</h3><p>格式：cmp 操作对象1，操作对象2</p>
<p>功能：计算操作对象1-操作对象2</p>
<p>应用：通过cmp指令执行后相关标志位的值，可以看出比较的结果、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp ax,bx<br>;ZF=1 (AX)=(BX)<br>;ZF=0 (AX)!=(BX)<br>;CF=1 (AX)&lt;(BX)，产生了借位<br>;CF=0 (AX)&gt;=(BX),不必借位,当且仅当ZF=1时为等于<br></code></pre></td></tr></table></figure>

<p>条件转移指令中各符号的意思：</p>
<p>j-jump e-equal n-not b-below a-above l-less g-greater s-sign c-carry p-parity o-overflow z-zero</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;如果（ah）=(bh),则(ah)=(ah)+(ah),否则（ah)=(ah)+(bh)<br>cmp ah,bh<br>je s<br>add ah,bh<br>jmp short ok<br>s:add ah,ah<br>ok:ret<br></code></pre></td></tr></table></figure>

<h3 id="DF标志及串传送指令"><a href="#DF标志及串传送指令" class="headerlink" title="DF标志及串传送指令"></a>DF标志及串传送指令</h3><p>DF&#x3D;0,每次操作后si,di递增，否则递减。递增和递减的大小取决于传送的单位</p>
<h5 id="movsb-以字节单位传送"><a href="#movsb-以字节单位传送" class="headerlink" title="movsb:以字节单位传送"></a>movsb:以字节单位传送</h5><h5 id="movsw以字单位传送"><a href="#movsw以字单位传送" class="headerlink" title="movsw以字单位传送"></a>movsw以字单位传送</h5><h5 id="rep指令"><a href="#rep指令" class="headerlink" title="rep指令"></a>rep指令</h5><p>功能：根据cx的值，重复执行后面的指令</p>
<p>用法:	rep movsb&#x3D;s:movsb </p>
<p>​									loop s</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code,ds:data<br>data segment<br>	db &#x27;welcome to masm!&#x27;<br>	db 16 dup(0)<br>data ends<br>code segment<br>start:<br>	mov ax,data<br>	mov ds,ax<br>	mov es,ax<br>	mov si,0;源地址寄存器<br>	mov di,16;目标地址寄存器<br>	cld；将DF设置为0，std将DF设置为1<br>	mov cx,8<br>	rep movsw<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p>逻辑左移SHL</p>
<p>逻辑右移SHR</p>
<p>循环左移ROL</p>
<p>循环右移ROR</p>
<p>算数左移SAL</p>
<p>算术右移SAR</p>
<p>带进位循环左移RCL</p>
<p>带进位循环右移RCR</p>
<p>RO-rotate,C-carry</p>
<h5 id="移位指令-OPR-CNTOPR代表操作数，CNT表述移动数位"><a href="#移位指令-OPR-CNTOPR代表操作数，CNT表述移动数位" class="headerlink" title="移位指令+OPR+CNT	OPR代表操作数，CNT表述移动数位"></a>移位指令+OPR+CNT	OPR代表操作数，CNT表述移动数位</h5><p>用法：左移乘以2，右移除以二</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,00000001b;(al)=1<br>shl al,1;(al)=2<br>mov cl,3<br>shl al,cl;(al)=16<br></code></pre></td></tr></table></figure>

<h3 id="操作显存数据"><a href="#操作显存数据" class="headerlink" title="操作显存数据"></a>操作显存数据</h3><p>屏幕上的数据&#x3D;显存内的数据</p>
<p>显存空间：128kRAM <strong>其中B8000H-BFFFFH共32k空间是80*25彩色字符模式第0页的显示缓冲区</strong>（80列25行）</p>
<p>每一行80个字，160个字节</p>
<p>低位字节放ASCII，高位字节放属性字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,data<br>mov ds,ax<br>mov ax,0b800h<br>mov es,ax<br>mov si,0<br>mov di,160*12+80-16<br><br>mov cx,16<br>w:mov al,[si]<br>mov es:[di],al<br>inc di<br>mov al,71h;颜色属性<br>mov es:[di],al<br>inc si<br>inc di<br>loop w<br>;直接显示<br></code></pre></td></tr></table></figure>

<h3 id="描述内存单元的标号"><a href="#描述内存单元的标号" class="headerlink" title="描述内存单元的标号"></a>描述内存单元的标号</h3><p>代码段中的数据也可以用标号</p>
<p>在code段使用标号但不使用冒号，使用字还是字节看后面，不加冒号的为数据标号，加冒号的为地址标号</p>
<h5 id="数据标号同时描述内存地址和单元长度"><a href="#数据标号同时描述内存地址和单元长度" class="headerlink" title="数据标号同时描述内存地址和单元长度"></a>数据标号同时描述内存地址和单元长度</h5><h5 id="地址标号只能在代码段使用"><a href="#地址标号只能在代码段使用" class="headerlink" title="地址标号只能在代码段使用"></a>地址标号只能在代码段使用</h5><h6 id="seg的作用是取段地址"><a href="#seg的作用是取段地址" class="headerlink" title="seg的作用是取段地址"></a>seg的作用是取段地址</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br>code segment<br>start:<br>	mov al,60<br>	call showsin<br>	mov ax,4c00h<br>	int 21h<br>	<br>	showsin:<br>	jmp shortshow<br>	;字符串偏移地址表<br>	table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180<br>	ag0 db &#x27;0&#x27;,0<br>	……<br>	;预备<br>	push bx<br>	push es<br>	push si<br>	<br>	mov bx,0b800h<br>	mov es,bx<br>	;取相应字符串的偏移地址放在bx内<br>	mov ah,0<br>	mov bl,30<br>	div bl;相当于60/30<br>	mov bl,al;结果在al中<br>	mov bh,0<br>	add bx,bx;每一个都是dw类型<br>	mov bx,table[bx]<br>	;显示对应字符串<br>	mov si,160*12+40*2<br>	shows:<br>	mov ah,cs:[bx]<br>	cmp ah,0<br>	je showret<br>	mov es:[si],ah;显示<br>	inc bx<br>	add si,2<br>	jmp shows<br>	;善后<br>	pop di<br>	pop es<br>	pop bx<br>	ret<br>code ends<br>end start<br></code></pre></td></tr></table></figure>



<h3 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h3><p>问题：以十六进制的形式在屏幕中间娴熟给定的byte型数据</p>
<p>分析：把一个byte的高四位和第四位分开，显示对应的数码字符</p>
<p>利用表，在两个数据集合之间建立一种映射关系，用查表的方法根据给出的数据得到其在另一集合中的数据</p>
<p>ah放功能号，al放属性号</p>
<h3 id="中断及其处理"><a href="#中断及其处理" class="headerlink" title="中断及其处理"></a>中断及其处理</h3><p>内中断：CPU内部发生的事件引起的中断</p>
<p>外中断：外部设备发生的事情引起的中断</p>
<p>8086的内中断：</p>
<p>​	除法错误：div指令产生除法溢出；中断码0</p>
<p>​	单步执行：中断类型码1</p>
<p>​	执行into指令：中断类型码4</p>
<p>​	执行int指令：执行int n指令，立即数为中断类型码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;lea取得相应标号地址，lea a,b 把b的地址放入a<br>;13,10回车换行<br>;&#x27;$&#x27;字符串<br>;int 21h处理dos信息<br>;mov ah,9显示字符串<br>;ds:dx显示的是从这里取了显示<br></code></pre></td></tr></table></figure>

<h5 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h5><p>CPU接收到中断信息执行中断处理程序</p>
<p>中断信息和其处理程序的入口地址之间有某种联系</p>
<p>中断向量表可以由中断类型码查表得到中断处理程序</p>
<p>高位放CS，低位放IP</p>
<h5 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h5><p>中断过程由CPU的硬件自动完成</p>
<p>IP&#x3D;4N,CS&#x3D;4N+2</p>
<h5 id="设置中断向量表"><a href="#设置中断向量表" class="headerlink" title="设置中断向量表"></a>设置中断向量表</h5><p>把程序的入口地址，写道中断向量表对应的n号表项中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;求2*3456^2,写中断7ch的中断例程完成任务<br>;iret主要用于中断子程序中<br>assume cs:code <br>code segment<br>start:<br>	mov ax,cs<br>	mov ds,ax<br>	mov si,offset sqr;源地址<br>	mov ax,0<br>	mov es,ax<br>	mov di,200h;目的地址<br>	mov cx,offset sqrend-offset sqr;循环次数<br>	cld <br>	rep movsb<br>	<br>	mov ax,0<br>	mov es,ax<br>	mov word ptr es:[7ch*4],200h;ip<br>	mov word ptr es:[7ch*4+2],0;cs<br>	mov ax,4c00h<br>	int 21h<br>	<br>	sqr:<br>	mul ax<br>	iret<br>	sqrend:nop<br>code ends<br>end start<br><br>;调用中断例程<br>code segment<br>start:<br>	mov ax,3456<br>	int 7ch<br>	add ax,ax<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure>



<h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>TF（陷阱标志）标志为1，让CPU处在单步中断方式下</p>
<p>IF（中断标志）标志为1，允许CPU相应可屏蔽中断请求，IF&#x3D;0关闭中断</p>
<p>中断过程：</p>
<p>​	取得中断类型码N</p>
<p>​	标志寄存器入栈，TF,IF置为0</p>
<p>​	CS,IP入栈</p>
<p>​	IP&#x3D;4N CS&#x3D;4N+2</p>
<h5 id="中断不响应的情况"><a href="#中断不响应的情况" class="headerlink" title="中断不响应的情况"></a>中断不响应的情况</h5><p>ss:sp联合指向栈顶，对他们的涉资连续完成，不进行单步执行</p>
<h3 id="由int指令引起的中断"><a href="#由int指令引起的中断" class="headerlink" title="由int指令引起的中断"></a>由int指令引起的中断</h3><p>中断过程与上方一致</p>
<h3 id="BIOS基本输入输出系统"><a href="#BIOS基本输入输出系统" class="headerlink" title="BIOS基本输入输出系统"></a>BIOS基本输入输出系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;bios中断调用示例<br>;在屏幕的五行十二列显示三个红底高亮闪烁绿色的&#x27;a&#x27;;<br>assume cs:code<br>code segment<br>	mov ah,2;置光标功能<br>	mov bh,0;第0页<br>	mov dh,5;第五行<br>	mov dl,12;十二列<br>	int 10h;bios10号中断例程<br>	<br>	mov ah,9;显示字符功能<br>	mov al,&#x27;a&#x27;;<br>	mov bl,11001010b;颜色属性<br>	mov bh,0;第0页<br>	mov cx,3;三遍<br>	int 10h<br>	<br>	mov ax,4c00h<br>	int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure>



<h3 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h3><p>in从端口读取数据和out输出数据</p>
<p>设备控制寄存器61h</p>
<p>端口对应除CPU以外的外部设备</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/15/%E6%B6%88%E6%81%AF%E8%BD%B0%E7%82%B8%E7%AE%80%E6%B4%81%E4%BB%A3%E7%A0%81/">
                        <span class="hidden-mobile">消息轰炸</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
